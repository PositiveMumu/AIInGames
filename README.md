# 游戏中的AI
## 一、寻路算法

### 1. 介绍

寻路算法分为传统寻路算法(TraditionalPathfinding)和A*寻路算法(AStarPathfinding)。

传统寻路算法包括：

- 深度优先搜索算法——BFS
- 广度优先搜索算法——DFS

启发式搜索算法包括A\*寻路算法。该算法综合了[最良优先搜索](https://zh.wikipedia.org/w/index.php?title=最良優先搜索&action=edit&redlink=1)和[Dijkstra算法](https://zh.wikipedia.org/wiki/Dijkstra算法)的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。

### 2. 使用方法

**传统寻路算法的使用方法：**

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. BFSSystem和DFSSystem为两个静态工具类，用来进行寻路操作。
3. 在进行寻路前需要调用`InitMap`方法。方法接受两个参数，第一个参数是将游戏地图数字化的二维整形数组，第二个参数是整形类型的障碍物标识，代表地图中不可通过的点在数字地图中的标识。
4. 调用`Search`方法来获得查找的路径。方法返回值位bool类型，表示寻路是否成功。方法接受三个参数，第一个参数是Node类型的对象，代表起始节点。第二个参数是Node类型的对象，代表目标节点。第三个参数是Node的列表，代表寻找到的路径节点，使用ref关键字标识。Node类是工具组已经定义的类，构造方法接受三个参数——X、Y、Value，分别代表横坐标、纵坐标、该位置数字地图中的标识。

**A\*寻路算法的使用方法**

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. 工具中提供了一个基础的地图节点类`AStarNode`，该类可以满足基本简单地图的寻路工作。该类支持用户继承并重写方法来构造自己的节点类型。AStarNode类中的F值属性、当前节点的邻居节点属性、获得G值的方法和获得H值的方法都支持重写。AStarNode类构造方法接受三个参数——X、Y、nodeType，分别代表横坐标、纵坐标、该位置数字地图中的标识。
3. AStarSystem是一个普通类，使用时需要先声明一个该类的对象。
4. 在进行寻路前需要调用`InitMap`方法。方法接受两个参数，第一个参数是将游戏地图数字化的二维整形数组，第二个参数是整形类型的障碍物标识，代表地图中不可通过的点在数字地图中的标识。
5. 调用`FindPath`方法来获得查找的路径。方法返回值位bool类型，表示寻路是否成功。方法接受三个参数，第一个参数是AStarNode类型的对象，代表起始节点。第二个参数是AStarNode类型的对象，代表目标节点。第三个参数是AStarNode的列表，代表寻找到的路径节点，使用ref关键字标识。
6. 在使用用户自定的节点类时，有几个需要注意的地方：
   - `FindPath`方法传递的初始与目标节点的类型必须为用户自定义的节点类型的对象，如果使用默认的AStarNode类型的对象，程序会执行最基础的查询方法。
   - 当用户自定义的节点类型的构造函数存在比默认AStarNode节点类型多的参数时，用户需要重写在自定义的节点类型中重写获得当前节点的邻居节点方法。在该方法中创建自定义的节点类型对象并返回。具体可参考AStarNode类中的NeighborNotes属性，自定义类型中重写该方法时只需要将AStarNode类改为自定义的类型并传递参数即可。

### 3. 注意事项

- BFS与DFS方法为四方向寻路算法，可以根据需要对BFSSystem/DFSSystem的进行更改来支持八方向。
- DFS并不适合作为寻路算法，DFS更适合用来判断图中的连通性。
- 在地图特别庞大时DFS的效率比BFS效率高一些。但是DFS寻找的路径并不是最优的。
- 工具中提供的DFS方法只返回第一条深度搜索到的路径，所以基本不是最优的。使用DFS可以得到最优路径，只需要遍历所有符合的路径并选出最短的路径即可（该方法可以剪枝）。
- A\*寻路算法可以通过自定义实现很神奇的效果，详细可以参考笔者的[密室寻宝](https://github.com/PositiveMumu/TreasureHunt)。其中对A\*寻路算法进行了定制以实现在寻路过程中优先获得路径上的道具的功能。

## 二、有限状态机（Finite-State Machine）

### 1. 介绍

有限状态机Unity维基地址：http://wiki.unity3d.com/index.php/Finite_State_Machine。

FSM ，如其名有限状态机，就是说啊这是一个可以枚举出有限个状态，并且这些个状态在特定条件下能够来回切换的机器。在小游戏里面出现的简单 AI 体验：**`怪物巡逻、怪物追击、目标丢失继续巡逻、发生战斗血量不足逃跑、发生战斗血量为0死亡`**等等，大多出自它手啦！另外FSM的理念又似乎随处可见，细心的你有没有在某一刻发现 Unity 的 Animator 其实就是一个有限状态机呢？

在设计模式中有这样一种思想：

> 细节依赖抽象，抽象不依赖细节，基于抽象编程，让框架先跑起来。

FSM 把上面这句话演绎的淋漓尽致，俨然已经算的上是一个简单的框架了，只要遵循他的规则，你只要写细节实现就行，其他事情全部帮你驱动。FSM 跟 Switch case 语法做的事一样一样的，类比于 Switch 就是将case中的逻辑封装到各个State类型中了。那为啥这样做呢？答案很简单，就是为了方便扩展，如果后期需要加入新状态，只需要继承基类，添加实现就好，不用修改原来的代码，也不用担心什么时候调用啦，这就叫**开闭原则**（开闭原则：对修改关闭对扩展开放）。

Tips：FSM 还是设计模式里的**状态模式**理念的集大成哦。

### 2. 使用方式

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. 创建一些状态类，并让他们继承FSMState，在状态类中重写`Action`方法（负责执行当前状态的操作）和`Reason`方法（负责判断并切换状态）。
3. 在需要使用状态机的类中进行如下操作：
   1. 实例化当前状态机管理的状态（通过构造方法传递参数），得到状态对象。
   2. 调用状态对象`AddTransition`方法添加当前状态的转换条件和转换后的状态的名称。方法接受两个参数：第一个参数String类型，表示转换条件；第二个参数String类型，表示在当前状态在转换条件下要转换到的状态的名称。
   3. 实例化状态机管理类FSMSystem，得到状态机对象。
   4. 调用状态机对象的`AddState`方法向状态机中添加管理的状态，第一个添加的状态会被设置成当前状态。方法接受一个参数，类型为FSMState，表示要管理的状态。
   5. 在需要地方可以调用状态机对象的`PerformTransition`方法来转换当前状态机执行的状态。方法接受一个String类型的参数，表示转换条件。
   6. 在Update函数中调用状态机对象的`UpdateMethod`方法，状态机开始运行。

### 3. 注意事项

1. 由于笔者提供的是一个小型框架，所以转换状态和状态名称都定义为String类型，在调用时可能会因为参数传入错误导致状态机运行错误。有两个解决方法：
   1. 在维基中提供的代码中将转换状态和状态名称都定义为枚举类型，可以有效的解决这个问题。
   2. 单独定义一个保存静态数据的类，将转换状态和状态名称定义为静态变量，在使用时直接使用变量，可以有效的解决这个问题。
2. 关于状态类中的数据，可以通过状态类的构造方法传递，也可以通过数据管理器、单例类等方法获得需要操作的数据。
3. 状态对象中的`RemoveTransition`方法可以删除转换状态和转换到的状态。方法接受一个String类型的参数，表示要删除的转换条件。
4. 状态机对象的`DeleteState`方法可以删除管理的状态。方法接受一个String类型的参数，表示要删除的转换条件的名称。
5. 状态机对象的`RevokeTransition`方法可以跳转回上一个状态（当前状态会变成上一个状态）。方法不需要参数。

### 4. 示例程序说明

示例程序与维基代码提供的基本相同。敌人维护一个状态机，状态机管理巡逻状态和追踪状态。敌人初始状态为沿着路径点移动的巡逻状态，当周围一定范围内出现玩家控制的角色时敌人会追踪玩家，当玩家原理敌人移动距离后敌人会切换回巡逻状态。玩家通过W、A、S、D控制移动。

## 三、分层有限状态机（Hierarchical Finite-State Machine）

### 1. 介绍

当FSM管理的状态太多的时候，不好维护。于是将状态分类，抽离出来，将同类型的状态做为一个状态机，然后再做一个大的状态机，来维护这些子状态机。框架中提供的为二层状态机，更多层次的状态机可以参考本程序的框架思路。

本框架为分层有限状态机和下压式有限状态机的组合。大状态机中管理小状态机的方式是栈，当转换状态时正在执行的子状态机会被压栈。新转换的状态机会执行。当当前状态机执行结束后可以转到新的子状态机，也可以结束执行，栈中上一状态的子状态机会出栈并继续执行。

详情参考示例程序。

### 2. 使用方式

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. 创建一些状态类，并让他们继承HFSMState，在状态类中重写`Action`方法（负责执行当前状态的操作）和`Reason`方法（负责判断并切换状态）。
3. 创建一些子状态机类，并让他们继承HFSMBaseSystem，可以在子类中添加子状态机特有参数、重写`UpdateMethod`方法。如果以上操作都不需要，则直接使用HFSMBaseSystem类即可。
4. 在需要使用状态机的类中进行如下操作：
   1. 实例化子状态机管理的状态（通过构造方法传递参数），得到状态对象。
   2. 调用状态对象`AddTransition`方法添加当前状态的转换条件和转换后的状态的名称。方法接受两个参数：第一个参数String类型，表示转换条件；第二个参数String类型，表示在当前状态在转换条件下要转换到的状态的名称。
   3. 实例化子状态机类，得到状态机对象。
   4. 调用子状态机对象的`AddState`方法向状态机中添加管理的状态，第一个添加的状态会被设置成当前状态。方法接受一个参数，类型为FSMState，表示要管理的状态。
   5. 实例化状态机管理类HFSMManagerSystem，得到管理状态机对象。
   6. 在需要地方可以调用子状态机对象的`PerformTransition`方法来转换当前状态机执行的状态。方法接受一个String类型的参数，表示转换条件。
   7. 在需要的地方可以调用管理状态机对象的`ChangeSystem`方法来切换子状态机。方法接受两个参数，第一个参数String类型，表示要转换的子状态机的名称，第二个可选参数为转换状态，代表切换到子状态机后，子状态机进行内部状态转移的名称，不输入即为不转换。
   8. 在Update函数中调用管理状态机对象的`UpdateMethod`方法，状态机开始运行。

### 3. 注意事项

1. 由于笔者提供的是一个小型框架，所以转换状态和状态名称都定义为String类型，在调用时可能会因为参数传入错误导致状态机运行错误。有两个解决方法：
   1. 在维基中提供的代码中将转换状态和状态名称都定义为枚举类型，可以有效的解决这个问题。
   2. 单独定义一个保存静态数据的类，将转换状态和状态名称定义为静态变量，在使用时直接使用变量，可以有效的解决这个问题。
2. 关于状态类中的数据，可以通过状态类的构造方法传递，也可以通过数据管理器、单例类等方法获得需要操作的数据。
3. 子类状态机对象中的`RemoveTransition`方法可以删除转换状态和转换到的状态。方法接受一个String类型的参数，表示要删除的转换条件。
4. 子类状态机对象的`DeleteState`方法可以删除管理的状态。方法接受一个String类型的参数，表示要删除的转换条件的名称。
5. 子类状态机对象的`RevokeTransition`方法可以跳转回上一个状态（当前状态会变成上一个状态）。方法不需要参数。
6. 管理状态机对象的`QuitCurrentState`方法可退出当前子状态机，继续执行上一个子状态机。方法接受一个可选的String类型的参数，代表切换到子状态机后，子状态机进行内部状态转移的名称。不输入即为不转换。

### 4. 示例程序

存在两个子状态机：家中子状态机，管理读书、做饭和睡觉三个状态；超时子状态机管理购物和付款状态，大的状态机管理两个子状态机。

两个子状态机都由时间驱动：

1. 家中子状态机前两秒为读书状态，再三秒为做饭状态，后十秒为睡觉状态。之后再转到读书状态。做饭时需要用到食盐，如果当前食盐不够会转到超市子状态机进行购物。
2. 超市子状态机两秒为购物状态，后三秒为付款状态。付款后会转回家中子状态机，在转回家中子状态机之前会采购一些食盐。