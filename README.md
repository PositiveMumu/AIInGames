# 游戏中的AI
## 一、寻路算法

### 1. 介绍

寻路算法分为传统寻路算法(TraditionalPathfinding)和A*寻路算法(AStarPathfinding)。

传统寻路算法包括：

- 深度优先搜索算法——BFS
- 广度优先搜索算法——DFS

启发式搜索算法包括A\*寻路算法。该算法综合了[最良优先搜索](https://zh.wikipedia.org/w/index.php?title=最良優先搜索&action=edit&redlink=1)和[Dijkstra算法](https://zh.wikipedia.org/wiki/Dijkstra算法)的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。

### 2. 使用方法

**传统寻路算法的使用方法：**

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. BFSSystem和DFSSystem为两个静态工具类，用来进行寻路操作。
3. 在进行寻路前需要调用`InitMap`方法。方法接受两个参数，第一个参数是将游戏地图数字化的二维整形数组，第二个参数是整形类型的障碍物标识，代表地图中不可通过的点在数字地图中的标识。
4. 调用`Search`方法来获得查找的路径。方法返回值位bool类型，表示寻路是否成功。方法接受三个参数，第一个参数是Node类型的对象，代表起始节点。第二个参数是Node类型的对象，代表目标节点。第三个参数是Node的列表，代表寻找到的路径节点，使用ref关键字标识。Node类是工具组已经定义的类，构造方法接受三个参数——X、Y、Value，分别代表横坐标、纵坐标、该位置数字地图中的标识。

**A\*寻路算法的使用方法**

1. 导入要使用UnityPackage或者DLL文件。UnityPackage中的Example文件夹下提供了一个示例程序。
2. 工具中提供了一个基础的地图节点类`AStarNode`，该类可以满足基本简单地图的寻路工作。该类支持用户继承并重写方法来构造自己的节点类型。AStarNode类中的F值属性、当前节点的邻居节点属性、获得G值的方法和获得H值的方法都支持重写。AStarNode类构造方法接受三个参数——X、Y、nodeType，分别代表横坐标、纵坐标、该位置数字地图中的标识。
3. AStarSystem是一个普通类，使用时需要先声明一个该类的对象。
4. 在进行寻路前需要调用`InitMap`方法。方法接受两个参数，第一个参数是将游戏地图数字化的二维整形数组，第二个参数是整形类型的障碍物标识，代表地图中不可通过的点在数字地图中的标识。
5. 调用`FindPath`方法来获得查找的路径。方法返回值位bool类型，表示寻路是否成功。方法接受三个参数，第一个参数是AStarNode类型的对象，代表起始节点。第二个参数是AStarNode类型的对象，代表目标节点。第三个参数是AStarNode的列表，代表寻找到的路径节点，使用ref关键字标识。
6. 在使用用户自定的节点类时，有几个需要注意的地方：
   - `FindPath`方法传递的初始与目标节点的类型必须为用户自定义的节点类型的对象，如果使用默认的AStarNode类型的对象，程序会执行最基础的查询方法。
   - 当用户自定义的节点类型的构造函数存在比默认AStarNode节点类型多的参数时，用户需要重写在自定义的节点类型中重写获得当前节点的邻居节点方法。在该方法中创建自定义的节点类型对象并返回。具体可参考AStarNode类中的NeighborNotes属性，自定义类型中重写该方法时只需要将AStarNode类改为自定义的类型并传递参数即可。

### 3. 注意事项

- BFS与DFS方法为四方向寻路算法，可以根据需要对BFSSystem/DFSSystem的进行更改来支持八方向。
- DFS并不适合作为寻路算法，DFS更适合用来判断图中的连通性。
- 在地图特别庞大时DFS的效率比BFS效率高一些。但是DFS寻找的路径并不是最优的。
- 工具中提供的DFS方法只返回第一条深度搜索到的路径，所以基本不是最优的。使用DFS可以得到最优路径，只需要遍历所有符合的路径并选出最短的路径即可（该方法可以剪枝）。
- A\*寻路算法可以通过自定义实现很神奇的效果，详细可以参考笔者的[密室寻宝](https://github.com/PositiveMumu/TreasureHunt)。其中对A\*寻路算法进行了定制以实现在寻路过程中优先获得路径上的道具的功能。

## 二、有限状态机（Finite-State Machine）

